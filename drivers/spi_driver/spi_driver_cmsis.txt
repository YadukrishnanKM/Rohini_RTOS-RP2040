#include "spi_driver.h" // Replace with your MCU-specific CMSIS header
#include "hardware/resets.h"

#include "RP2040.h"
#include "hardware/address_mapped.h"
#include "hardware/clocks.h" 
#include "hardware/pll.h"

// #include "hardware/regs/spi.h"
// #include "hardware/regs/io_bank0.h"
// #include "hardware/regs/sio.h"
// #include "hardware/regs/resets.h"
// #include "hardware/regs/pads_bank0.h"
#include "hardware/regs/clocks.h"

#include "hardware/structs/spi.h"
#include "hardware/structs/io_bank0.h"
#include "hardware/structs/sio.h"
#include "hardware/structs/resets.h"
#include "hardware/structs/pads_bank0.h"
#include "hardware/structs/clocks.h"
#include "hardware/structs/pll.h"

#define IO_BANK0_GPIO0_CTRL_FUNCSEL_VALUE_SPI0_SCLK 0x01u
#define IO_BANK0_GPIO0_CTRL_FUNCSEL_VALUE_SPI0_TX 0x01u
#define CLOCKS_CLK_PERI_DIV_OFFSET CLOCKS_CLK_USB_CTRL_OFFSET

#define pads_bank0_hw_io_pue (1u << 3)  //@brief Pull-up enable bit mask
#define pads_bank0_hw_io_pde (1u << 2)  //@brief Pull-down enable bit mask




static inline __attribute__((always_inline)) void SPI_begin(uint32_t target_baud, uint sck, uint mosi, uint miso) {
    // --- Step 1: Unreset SPI0 ---
    resets_hw->reset &= ~RESETS_RESET_SPI0_BITS;
    // Wait until SPI0 is out of reset
    while (!(resets_hw->reset_done & RESETS_RESET_DONE_SPI0_BITS));


    // --- Step 2: Configure GPIO functions ---
    io_bank0_hw->io[sck].ctrl  = IO_BANK0_GPIO0_CTRL_FUNCSEL_VALUE_SPI0_SCLK;
    io_bank0_hw->io[mosi].ctrl = IO_BANK0_GPIO0_CTRL_FUNCSEL_VALUE_SPI0_TX;
    io_bank0_hw->io[miso].ctrl = IO_BANK0_GPIO0_CTRL_FUNCSEL_VALUE_SPI0_RX;

    // --- Step 3: Disable pulls ---
    pads_bank0_hw->io[sck]  &= ~pads_bank0_hw_io_pue;  pads_bank0_hw->io[sck]  &= ~pads_bank0_hw_io_pde;
    pads_bank0_hw->io[mosi] &= ~pads_bank0_hw_io_pue;  pads_bank0_hw->io[mosi] &= ~pads_bank0_hw_io_pde;
    pads_bank0_hw->io[miso] &= ~pads_bank0_hw_io_pue;  pads_bank0_hw->io[miso] &= ~pads_bank0_hw_io_pde;

    // --- Step 4: Enable output for SCK and MOSI ---
    sio_hw->gpio_oe_set = (1u << sck) | (1u << mosi);

    // --- Step 5: Get clk_peri from CLOCKS divider ---
    
    spi0_hw->baud = get_clk_peri() / target_baud;

    // --- Step 6: Configure SPI0 format ---
    spi0_hw->cr0 = (7 << SPI_SSPCR0_DSS_LSB) | (scr << SPI_SSPCR0_SCR_LSB);

    // --- Step 7: Set prescaler ---
    spi0_hw->cpsr = cpsr;

    // --- Step 8: Enable SPI0 ---
    spi0_hw->cr1 = SPI_SSPCR1_SSE_BITS;
}

static inline __attribute__((always_inline)) uint8_t SPI_transfer(uint8_t data) {
    while (!(spi0_hw->sr & SPI_SSPSR_TNF_BITS)) {}
    spi0_hw->dr = data;
    while (!(spi0_hw->sr & SPI_SSPSR_RNE_BITS)) {}
    return spi0_hw->dr;
}

static inline __attribute__((always_inline)) void SPI_transferBytes(const uint8_t *tx, uint8_t *rx, size_t len) {
    for (size_t i = 0; i < len; ++i) {
        rx[i] = SPI_transfer(tx[i]);
    }
}

static inline __attribute__((always_inline)) void SPI_beginTransaction(uint32_t baud, uint cpol, uint cpha) {
    spi0_hw->cr1 = 0; // Disable SPI
    spi0_hw->cr0 = (7 << SPI_SSPCR0_DSS_LSB) |
                   ((cpol & 1) << SPI_SSPCR0_SPO_LSB) |
                   ((cpha & 1) << SPI_SSPCR0_SPH_LSB);
    spi0_hw->cpsr = 2;
    spi0_hw->cr1 = SPI_SSPCR1_SSE_BITS;
}

static inline __attribute__((always_inline)) void SPI_endTransaction(void) {
    // No-op
}

static inline __attribute__((always_inline)) void SPI_transferDMA(const uint8_t *tx, uint8_t *rx, size_t len) {
    // Blocking fallback
    SPI_transferBytes(tx, rx, len);
}



#define CLK_REF_DIV_ADDR   ((io_rw_32 *)(CLOCKS_BASE + 0x34))
#define CLK_PERI_DIV_ADDR  ((io_rw_32 *)(CLOCKS_BASE + 0x5C)) // fixed offset

static inline uint32_t get_clk_peri_freq(void) {
    // Read PLL_SYS config
    uint32_t fbdiv    = pll_sys_hw->fbdiv_int;
    uint32_t prim     = pll_sys_hw->prim;
    uint32_t postdiv1 = (prim >> PLL_PRIM_POSTDIV1_LSB) & 0x7;
    uint32_t postdiv2 = (prim >> PLL_PRIM_POSTDIV2_LSB) & 0x7;

    // Read clk_ref.div
    uint32_t ref_div = *CLK_REF_DIV_ADDR & 0xFFFF;
    uint32_t ref_freq = 12000000 / (ref_div | 1); // branchless

    // Compute clk_sys
    uint32_t clk_sys = (ref_freq * fbdiv) / ((postdiv1 | 1) * (postdiv2 | 1)); // branchless

    // Read clk_peri.div
    uint32_t peri_div = *CLK_PERI_DIV_ADDR & 0xFFFF;
    return clk_sys / (peri_div | 1); // branchless
}



